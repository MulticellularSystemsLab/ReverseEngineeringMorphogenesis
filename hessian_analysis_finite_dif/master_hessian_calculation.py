# -*- coding: utf-8 -*-
"""
Created on Tue Jul  6 23:35:16 2021

@author: Nilay, Code for doing hessian analysis on frechet error
"""
# Importing libraries
import pandas as pd
import matplotlib.pyplot as plt
import spatial_efd
import math 
import signac
import numpy as np
import os.path
import os
import torch
import gpytorch
import subprocess
import gc
import similaritymeasures
from matplotlib import pyplot as plt
from sklearn.preprocessing import StandardScaler
from smt.sampling_methods import LHS

# Importing helper libraries for bayesian optimization
from dependencies.data_preprocessing_class import dataPreprocessing
from dependencies.gaussian_process_regression_class import gaussianProcessRegression
from dependencies.acquisition_functions_class import acqisitionFunctions
from dependencies.geometry_writer import geometryWriter
from dependencies.feature_extractor_4 import FeatureExtractor
from parameter_samplin import sampleParameters

"""
STEP 1: Reading in the target shape data (point around which hessian has to be calculated)
"""
# Reading the vertices output file from a sample SE simulation output with known parameters
fe_exp = FeatureExtractor('input_data/vertices_target_SE.txt', 'log_edges.xlsx')
# Extracting the efd coefficients describing the basal epithelia
dummy11, coeffs_exp_basal, dummy12, dummy21, coeffs_exp_apical, dummy22 = fe_exp.tissue_efd_coeff(20)
# Obtaining normalized x and y coordinates for the apical surface of the tissue
xt_exp_apical, yt_exp_apical = spatial_efd.inverse_transform(coeffs_exp_apical, harmonic=20)
exp_data_apical = np.zeros((300,2))
exp_data_apical[:,0] = xt_exp_apical
exp_data_apical[:,1] = yt_exp_apical
# Obtaining normalized x and y coordinates for the basal surface of the tissu
xt_exp_basal, yt_exp_basal = spatial_efd.inverse_transform(coeffs_exp_basal, harmonic=20)
exp_data_basal = np.zeros((300,2))
exp_data_basal[:,0] = xt_exp_basal
exp_data_basal[:,1] = yt_exp_basal

"""
STEP 2: Hessian analysis
"""
# Number of parameters varied in LHS
n_param_model = 7
# Indices of the parameters varied during the LHS
param_index_model = [17,18,19,28,29,30,33]
# initializing the error array for storing the frechet errors
error_target_sampled_apical = []
error_target_sampled_basal = []
# Initializing the array for storing the parameter values
param_sampled = np.zeros((300,35))
# Initializing the array for storing the shape output features
curvature_basal_master = np.zeros((300,129))
tissue_edge_length_master = np.zeros((300,390))

# Counter for iterations
k = 0

"""
Iteration design:
1. Since the Hessian matrix is symmetric, in the first loop we iterate over all the
parameter and in the second loop we iterate  over the prameters exceeding the 
index the parametr in first loop by 1. This allows calculation of all the off 
diagonal elements of the hessian matrix
2. For each set of parameters (two at a time) 4 simulations are run ysing the sampleParam function
	- Both param increased by 70%
	- Both param decreased by 70%
	- param 1 increased by 70% and param 2  decreased by 70%
	- param 1 decreased by 70% and param 2  increased by 70%
	
	Features for each simulation are stored 	
3. Diagonal elements rae computed using data generated by sensitivty_analysis_master.py
"""
# Looping over all the parameters except last
for i in range(n_param_model-1):	
	# Looping over all the paramnetsr exceeding the index of the first loop
	for j in range(i+1,n_param_model):
		# The counter is used to perturb the set of parametsr in both directions
		# Perturbation in two parameters within th emodel  are made at a time 
		for hess_ctr in range(4):
			""" 
			STEP 2B : Defining parameters for the sensitivity analysis
			"""
			# Defining the equilibrium parameter
			paraminputsMaster = [0,3.162277660168379e-08,0,0,3.162277660168379e-08,0,0,1e-05,0,0,0, 0.1,0.1,10,0.1,0.1,0.1,0.01, 3.9810717055349695e-05, 0.01,0.001,0.001, 1,1,0.6,0.6,0.6,0.6,0.2,0.1,3,0.6,1.8, 0.002511886431509582,0.001]
			"""
			sampleParameters(paraminputsMaster,param_index_model,i,j, hess_ctr)
			param_index_model: Array containing the indexes of parameters for which hessian analysis is done
			i - Index of parameter 1 in the array above to be varied
			j - Index of parameter 2 in the array above to be varied
			hess_ctr:
               0 = Both param increased by 70%
				- 1 = Both param decreased by 70%
				- 2 = param 1 increased by 70% and param 2  decreased by 70%
				- 3 = param 1 decreased by 70% and param 2  increased by 70%
			"""
			paraminputs = sampleParameters(paraminputsMaster,param_index_model,i,j, hess_ctr)
			
			# Saving the parameter values
			param_sampled[k,:] = paraminputs
			
			"""
			STEP 2B :  Running surface evolver and extracting shape information
			"""
			
			# Defining the set system pressure
			param_pressure = 0.001
			# Writing geometry file
			geometryWriter(paraminputs, param_pressure, 'wingDisc')
			# Running surface evolver simulations, Can be replaced using python subprocess
			os.system("/home/nkumar4/Desktop/evolver_installation/src/evolver wingDisc.fe")
			# Calling in the feature extractor module to extract geometrical features from the sampled shape
			fe = FeatureExtractor('vertices.txt', 'log_edges.xlsx')
			# Extracting EFD coeeficients representing the basal and apical surfaces of the pouch
			dummy11, efd_coeff_sampled_basal, dummy12, dummy21, efd_coeff_sampled_apical, dummy22 = fe.tissue_efd_coeff(20)
			# Applying reverse EFD to extract the xy cordinates of the normalized apical and basal surface
			xt_sampled_apical, yt_sampled_apical = spatial_efd.inverse_transform(efd_coeff_sampled_apical, harmonic=20)
			xt_sampled_basal, yt_sampled_basal = spatial_efd.inverse_transform(efd_coeff_sampled_basal, harmonic=20)
			
			# Extracting and storing the curvature feature in master array
			curvature_basal_sampled = fe.tissue_local_curvature()
			curvature_basal_sampled_reshaped = np.reshape(curvature_basal_sampled, (1, 129))
			curvature_basal_master[k,:] = curvature_basal_sampled_reshaped
			
			# Extracting and storing the cell length feature in master array
			tissue_edge_length_sampled = fe.edge_length()
			tissue_edge_length_sampled_reshaped = np.reshape(tissue_edge_length_sampled, (1, 390))
			tissue_edge_length_master[k,:] = tissue_edge_length_sampled_reshaped
			
			# MOving the counter forward
			k = k + 1
			
			"""
			STEP 3C: Plotting the sampled and target shape
			"""
			# Defining filename for plot showing overlap between the sampled shape and the target shape
			filename_shape_plot_apical = str(i) + "_" + str(j) + "_" + str(hess_ctr) + "apical_sapled_target_xy_plot.svg"
			filename_shape_plot_basal = str(i) + "_" + str(j) + "_" + str(hess_ctr) + "basal_sapled_target_xy_plot.svg"
			# Plotting target data
			plt.plot(xt_exp_apical,yt_exp_apical,'black', label='Target')
			# Plotting sampled data
			plt.plot(xt_sampled_apical, yt_sampled_apical,'blue', label='Sampled')
			plt.axes().set_aspect('equal', 'datalim')
			# Labeling axes
			plt.xlabel("x [nondimensional]")
			plt.ylabel("y [nondimensional]")
			# Plotting legends
			plt.legend()
			plt.savefig("contour_evolution_plots/" + filename_shape_plot_apical)
			plt.close()
			# Repeating the same plotting excercise above for the basal surface visualization
			plt.plot(xt_exp_basal,yt_exp_basal,'black', label='Target')
			plt.plot(xt_sampled_basal, yt_sampled_basal,'blue', label='Sampled')
			plt.axes().set_aspect('equal', 'datalim')
			plt.xlabel("x [nondimensional]")
			plt.ylabel("y [nondimensional]")
			plt.legend()
			plt.savefig("contour_evolution_plots/" + filename_shape_plot_basal)
			plt.close()
			
			"""
			STEP 3D: Caculating frechet distances for measuring the errors of the 
			apical and basal surfaces of the sampled shape from the equilibrium shape
			"""
			# Initializing arrays for storing the xy coordinates of normalized apical and basal surfaces
			sampled_data_apical = np.zeros((300,2))
			sampled_data_basal = np.zeros((300,2))
			# Storing the xy coordinates of the normalized apical surface using reverse efd
			sampled_data_apical[:,0] = xt_sampled_apical
			sampled_data_apical[:,1] = yt_sampled_apical
			# Storing the xy coordinates of the normalized basal surface using reverse efd
			sampled_data_basal[:,0] = xt_sampled_basal
			sampled_data_basal[:,1] = yt_sampled_basal
			# Calculating the Frechet distance between apical and basal surfaces of the equilibrium and sampled shapes
			error_target_sampled_step_apical = similaritymeasures.frechet_dist(exp_data_apical,sampled_data_apical)
			error_target_sampled_step_basal = similaritymeasures.frechet_dist(exp_data_basal,sampled_data_basal)
			# Appending the sampmled erro sin a master array 
			error_target_sampled_apical.append(error_target_sampled_step_apical)
			error_target_sampled_basal.append(error_target_sampled_step_basal)
			
			# Saving vertices 
			command_save_vertices = "cp vertices.txt vertices_" + str(i) + "_" + str(j) + "_" + str(hess_ctr) + ".txt"
			os.system(command_save_vertices)
			# Deleting unnecesssary surface evolver files
			os.system("rm vertices.txt")
			os.system("rm energylog.txt")
			os.system("rm specificenergylog.txt")
			# Deleting unnecessary variable generated within the loop
			del xt_sampled_apical
			del yt_sampled_apical
			del xt_sampled_basal
			del yt_sampled_basal
			del fe
			gc.collect()
			
	
"""Step 4: Saving important arrays as numpy files for further analysis
"""	
np.save('error_target_sampled_apical.npy',error_target_sampled_apical)
np.save('error_target_sampled_basal.npy',error_target_sampled_basal)
np.save('curvature_basal_master.npy',curvature_basal_master)
np.save('tissue_edge_length_master.npy',tissue_edge_length_master)
np.save('param_sampled.npy',param_sampled)
	
